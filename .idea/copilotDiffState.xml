<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/main/java/com/example/utils/patterns/DefaultSingleton.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/example/utils/patterns/DefaultSingleton.java" />
              <option name="originalContent" value="package com.example.utils.patterns;&#10;&#10;import java.lang.reflect.Constructor;&#10;import java.util.Objects;&#10;import java.util.function.Supplier;&#10;&#10;import lombok.AccessLevel;&#10;import lombok.NonNull;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.Synchronized;&#10;import lombok.experimental.FieldDefaults;&#10;import lombok.val;&#10;&#10;/**&#10; * Suporte para um holder singleton, seguro para threads e inicialização preguiçosa.&#10; *&#10; * Uso:&#10; * - fallback preguiçoso: DefaultSingleton.of(() -&gt; new DefaultImpl())&#10; * - fallback por classe: DefaultSingleton.of(DefaultImpl.class)&#10; * - inicialização explícita: holder.set(instance) ou holder.setIfAbsent(instance)&#10; *&#10; * O holder permite inicialização explícita antes da primeira chamada a get(). A implementação usa checagem inicial&#10; * sem bloqueio seguida de uma atualização sincronizada (compare-and-set) para garantir segurança em concorrência.&#10; */&#10;@RequiredArgsConstructor(access = AccessLevel.PRIVATE)&#10;@FieldDefaults(level = AccessLevel.PRIVATE)&#10;public final class DefaultSingleton&lt;T&gt; {&#10;&#10;&#9;final Supplier&lt;? extends T&gt; defaultSupplier;&#10;&#9;volatile T instance;&#10;&#10;    /**&#10;     * Cria um holder que irá instanciar {@code defaultClass} preguiçosamente quando necessário.&#10;     */&#10;    public static &lt;T&gt; DefaultSingleton&lt;T&gt; of(@NonNull Class&lt;? extends T&gt; defaultClass) {&#10;        Objects.requireNonNull(defaultClass, &quot;defaultClass não pode ser nulo&quot;);&#10;        return new DefaultSingleton&lt;&gt;(() -&gt; newInstance(defaultClass));&#10;    }&#10;&#10;    /**&#10;     * Cria um holder usando um Supplier como fallback de criação.&#10;     */&#10;    public static &lt;T&gt; DefaultSingleton&lt;T&gt; of(@NonNull Supplier&lt;? extends T&gt; defaultSupplier) {&#10;        Objects.requireNonNull(defaultSupplier, &quot;defaultSupplier não pode ser nulo&quot;);&#10;        return new DefaultSingleton&lt;&gt;(defaultSupplier);&#10;    }&#10;&#10;    private static &lt;T&gt; T newInstance(Class&lt;? extends T&gt; clazz) {&#10;        try {&#10;            Constructor&lt;? extends T&gt; ctor = clazz.getDeclaredConstructor();&#10;            if (!ctor.canAccess(null)) {&#10;                try {&#10;                    ctor.setAccessible(true);&#10;                } catch (SecurityException ignored) {&#10;                    // Se não for possível alterar a acessibilidade, tentamos instanciar mesmo assim&#10;                }&#10;            }&#10;            return ctor.newInstance();&#10;        } catch (ReflectiveOperationException ex) {&#10;            throw new IllegalStateException(&quot;Não foi possível instanciar a classe &quot; + clazz.getName()&#10;                + &quot;. Verifique se existe um construtor padrão e se a classe é acessível.&quot;, ex);&#10;        }&#10;    }&#10;&#10;&#9;/**&#10;&#9; * Get the singleton instance. If not initialized it will be created using the supplier (which may instantiate the fallback class).&#10;&#9; */&#10;&#9;public T get() {&#10;&#9;&#9;if (instance == null) {&#10;&#9;&#9;&#9;setInstance(null, defaultSupplier);&#10;&#9;&#9;}&#10;&#9;&#9;return instance;&#10;&#9;}&#10;&#10;    /**&#10;     * Define explicitamente a instância antes da inicialização. Lança se já inicializado.&#10;     * Útil para frameworks de DI que registram o bean antecipadamente.&#10;     */&#10;    public void set(@NonNull T value) {&#10;        Objects.requireNonNull(value, &quot;value não pode ser nulo&quot;);&#10;        set(() -&gt; value);&#10;    }&#10;&#10;    public void set(@NonNull Supplier&lt;T&gt; supplier) {&#10;        Objects.requireNonNull(supplier, &quot;supplier não pode ser nulo&quot;);&#10;        boolean set = false;&#10;        if (instance == null) {&#10;            set = setInstance(null, supplier);&#10;        }&#10;        if (!set) throw new IllegalStateException(&quot;Singleton já foi inicializado e não pode ser alterado.&quot;);&#10;    }&#10;&#10;    /**&#10;     * Tenta definir a instância apenas se ausente. Retorna true se definiu, false caso já exista.&#10;     */&#10;    public boolean setIfAbsent(@NonNull T value) {&#10;        Objects.requireNonNull(value, &quot;value não pode ser nulo&quot;);&#10;        return setIfAbsent(() -&gt; value);&#10;    }&#10;&#10;    /**&#10;     * Tenta definir a instância apenas se ausente. Retorna true se definiu, false caso já exista.&#10;     */&#10;    public boolean setIfAbsent(@NonNull Supplier&lt;T&gt; supplier) {&#10;        Objects.requireNonNull(supplier, &quot;supplier não pode ser nulo&quot;);&#10;        if (instance != null) return false;&#10;        return setInstance(null, supplier);&#10;    }&#10;&#10;    /**&#10;     * Indica se a instância já foi inicializada.&#10;     */&#10;    public boolean isInitialized() {&#10;        return instance != null;&#10;    }&#10;&#10;    /**&#10;     * Reseta o holder para não inicializado. Uso restrito (testes ou casos especiais).&#10;     */&#10;    public void reset() {&#10;        T current = instance;&#10;        if (current == null) return;&#10;        setInstance(current, () -&gt; null);&#10;    }&#10;&#10;    /**&#10;     * Operação sincronizada de compare-and-set.&#10;     * - Se o valor atual for igual a expected, aplica o supplier e retorna true.&#10;     * - Caso contrário, não modifica e retorna false.&#10;     */&#10;    @Synchronized&#10;    private boolean setInstance(T expected, @NonNull Supplier&lt;? extends T&gt; supplier) {&#10;        Objects.requireNonNull(supplier, &quot;supplier não pode ser nulo&quot;);&#10;        if (Objects.equals(instance, expected)) {&#10;            T value = supplier.get();&#10;            instance = value;&#10;            return true;&#10;        }&#10;        return false;&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.example.utils.patterns;&#10;&#10;import java.lang.reflect.Constructor;&#10;import java.util.Objects;&#10;import java.util.function.Supplier;&#10;&#10;import lombok.AccessLevel;&#10;import lombok.NonNull;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.Synchronized;&#10;import lombok.experimental.FieldDefaults;&#10;import lombok.val;&#10;&#10;/**&#10; * Suporte para um holder singleton, seguro para threads e inicialização preguiçosa.&#10; *&#10; * Uso:&#10; * - fallback preguiçoso: DefaultSingleton.of(() -&gt; new DefaultImpl())&#10; * - fallback por classe: DefaultSingleton.of(DefaultImpl.class)&#10; * - inicialização explícita: holder.set(instance) ou holder.setIfAbsent(instance)&#10; *&#10; * O holder permite inicialização explícita antes da primeira chamada a get(). A implementação usa checagem inicial&#10; * sem bloqueio seguida de uma atualização sincronizada (compare-and-set) para garantir segurança em concorrência.&#10; */&#10;@RequiredArgsConstructor(access = AccessLevel.PRIVATE)&#10;@FieldDefaults(level = AccessLevel.PRIVATE)&#10;public final class DefaultSingleton&lt;T&gt; {&#10;&#10;&#9;final Supplier&lt;? extends T&gt; defaultSupplier;&#10;&#9;volatile T instance;&#10;&#10;    /**&#10;     * Cria um holder que irá instanciar {@code defaultClass} preguiçosamente quando necessário.&#10;     */&#10;    public static &lt;T&gt; DefaultSingleton&lt;T&gt; of(@NonNull Class&lt;? extends T&gt; defaultClass) {&#10;        Objects.requireNonNull(defaultClass, &quot;defaultClass não pode ser nulo&quot;);&#10;        return new DefaultSingleton&lt;&gt;(() -&gt; newInstance(defaultClass));&#10;    }&#10;&#10;    /**&#10;     * Cria um holder usando um Supplier como fallback de criação.&#10;     */&#10;    public static &lt;T&gt; DefaultSingleton&lt;T&gt; of(@NonNull Supplier&lt;? extends T&gt; defaultSupplier) {&#10;        Objects.requireNonNull(defaultSupplier, &quot;defaultSupplier não pode ser nulo&quot;);&#10;        return new DefaultSingleton&lt;&gt;(defaultSupplier);&#10;    }&#10;&#10;    private static &lt;T&gt; T newInstance(Class&lt;? extends T&gt; clazz) {&#10;        try {&#10;            Constructor&lt;? extends T&gt; ctor = clazz.getDeclaredConstructor();&#10;            if (!ctor.canAccess(null)) {&#10;                try {&#10;                    ctor.setAccessible(true);&#10;                } catch (SecurityException ignored) {&#10;                    // Se não for possível alterar a acessibilidade, tentamos instanciar mesmo assim&#10;                }&#10;            }&#10;            return ctor.newInstance();&#10;        } catch (ReflectiveOperationException ex) {&#10;            throw new IllegalStateException(&quot;Não foi possível instanciar a classe &quot; + clazz.getName()&#10;                + &quot;. Verifique se existe um construtor padrão e se a classe é acessível.&quot;, ex);&#10;        }&#10;    }&#10;&#10;&#9;/**&#10;&#9; * Get the singleton instance. If not initialized it will be created using the supplier (which may instantiate the fallback class).&#10;&#9; */&#10;&#9;public T get() {&#10;&#9;&#9;if (instance == null) {&#10;&#9;&#9;&#9;setInstance(null, defaultSupplier);&#10;&#9;&#9;}&#10;&#9;&#9;return instance;&#10;&#9;}&#10;&#10;    /**&#10;     * Define explicitamente a instância antes da inicialização. Lança se já inicializado.&#10;     * Útil para frameworks de DI que registram o bean antecipadamente.&#10;     */&#10;    public void set(@NonNull T value) {&#10;        Objects.requireNonNull(value, &quot;value não pode ser nulo&quot;);&#10;        set(() -&gt; value);&#10;    }&#10;&#10;    public void set(@NonNull Supplier&lt;T&gt; supplier) {&#10;        Objects.requireNonNull(supplier, &quot;supplier não pode ser nulo&quot;);&#10;        boolean set = false;&#10;        if (instance == null) {&#10;            set = setInstance(null, supplier);&#10;        }&#10;        if (!set) throw new IllegalStateException(&quot;Singleton já foi inicializado e não pode ser alterado.&quot;);&#10;    }&#10;&#10;    /**&#10;     * Tenta definir a instância apenas se ausente. Retorna true se definiu, false caso já exista.&#10;     */&#10;    public boolean setIfAbsent(@NonNull T value) {&#10;        Objects.requireNonNull(value, &quot;value não pode ser nulo&quot;);&#10;        return setIfAbsent(() -&gt; value);&#10;    }&#10;&#10;    /**&#10;     * Tenta definir a instância apenas se ausente. Retorna true se definiu, false caso já exista.&#10;     */&#10;    public boolean setIfAbsent(@NonNull Supplier&lt;T&gt; supplier) {&#10;        Objects.requireNonNull(supplier, &quot;supplier não pode ser nulo&quot;);&#10;        if (instance != null) return false;&#10;        return setInstance(null, supplier);&#10;    }&#10;&#10;    /**&#10;     * Indica se a instância já foi inicializada.&#10;     */&#10;    public boolean isInitialized() {&#10;        return instance != null;&#10;    }&#10;&#10;    /**&#10;     * Reseta o holder para não inicializado. Uso restrito (testes ou casos especiais).&#10;     */&#10;    public void reset() {&#10;        T current = instance;&#10;        if (current == null) return;&#10;        setInstance(current, () -&gt; null);&#10;    }&#10;&#10;    /**&#10;     * Operação sincronizada de compare-and-set.&#10;     * - Se o valor atual for igual a expected, aplica o supplier e retorna true.&#10;     * - Caso contrário, não modifica e retorna false.&#10;     */&#10;    @Synchronized&#10;    private boolean setInstance(T expected, @NonNull Supplier&lt;? extends T&gt; supplier) {&#10;        Objects.requireNonNull(supplier, &quot;supplier não pode ser nulo&quot;);&#10;        if (Objects.equals(instance, expected)) {&#10;            T value = supplier.get();&#10;            instance = value;&#10;            return true;&#10;        }&#10;        return false;&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/main/java/com/example/utils/pool/monitoring/PoolMetricsCollector.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/main/java/com/example/utils/pool/monitoring/PoolMetricsCollector.java" />
              <option name="updatedContent" value="package com.example.utils.pool.monitoring;&#10;&#10;import java.util.List;&#10;import java.util.stream.Collectors;&#10;&#10;import com.example.utils.pool.PoolManager;&#10;import com.example.utils.pool.provider.commons.Commons2Pool;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;&#10;/** Collects metrics from all registered pools */&#10;@Slf4j&#10;@RequiredArgsConstructor&#10;public class PoolMetricsCollector {&#10;&#9;final PoolManager manager;&#10;&#10;&#9;public List&lt;PoolMetrics&gt; snapshot() {&#10;&#9;&#9;return manager.all().stream().map(pool -&gt; {&#10;&#9;&#9;&#9;if (pool instanceof Commons2Pool&lt;?&gt; commons) {&#10;&#9;&#9;&#9;&#9;return new PoolMetrics(&#10;&#9;&#9;&#9;&#9;&#9;commons.getName(),&#10;&#9;&#9;&#9;&#9;&#9;commons.getBorrowedCount(),&#10;&#9;&#9;&#9;&#9;&#9;commons.getIdleCount(),&#10;&#9;&#9;&#9;&#9;&#9;commons.getConfig().getMaxTotal(),&#10;&#9;&#9;&#9;&#9;&#9;commons.getConfig().getMaxIdle(),&#10;&#9;&#9;&#9;&#9;&#9;commons.getConfig().getMinIdle()&#10;&#9;&#9;&#9;&#9;);&#10;&#9;&#9;&#9;}&#10;&#9;&#9;&#9;return new PoolMetrics(pool.getName(), -1, -1, -1, -1, -1);&#10;&#9;&#9;}).collect(Collectors.toList());&#10;&#9;}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>